(* -- "Load.m": Read Data from Files -------------------------------- *)

BeginPackage[
  "TopoID`Load`",
  {"TopoID`Common`",

   "TopoID`System`",

   "TopoID`Setup`",
   "TopoID`Topology`"}];

(* provided functions:

GetDiagrams[<file(s)>, [<name(s)>], [opts]],
GetDiagram[<file # name>, [opts]] -> alias
-- read from file FORM code of diagrams

GetTopologies[<file(s)>, [<name(s)>], [opts]]
GetTopology[<file # name>, [opts]] -> alias
-- read from file FORM code of topologies

*)



ClearAll[GetDiagrams];

ClearAll[GetTopologies];



GetDiagrams::usage = "\
GetDiagrams[<file(s)>, [<name(s)>], [opts]] reads from the file(s) \
<file(s)> in FORM format the diagrams listed in [<name(s)>] if \
specified, else all diagrams are read.  The search path can be \
adjusted via the option [Path].";

GetTopologies::usage = "\
TODO";






Begin["`Private`"];

(* --- GetDiagrams -------------------------------------------------- *)

(* ---- description ------------------------------------------------- *)

(* GetDiagrams[<fn>, [opts]]
arguments:
  <fn> -- string containing the filename of a diagram (".dia"-)file
    generated by QGRAF with the appropriate style (".sty"-)file.
options:
  [Path] -- directory in which to look for the .dia-file <fn>,
  [Status] -- flag for dynamic status updates, and
  [Verbosity] -- level of additional output (cf. VerbosityRules).
output:
  Information controlled by [Verbosity] and error messages in case a
  file is not readable or corrupted or conversion to an expression
  failed.
return:
  List of diagrams, each formatted like
    {name -> "D1",
     hist -> {GetDiagrams -> "<some_path>/1.gr.dia", name -> "D1"},
     legs -> {{"gl", p1, in[1], 1},
              {"gl", p2, in[2], 1},
              {"gl", p1, 2, out[3]},
              {"gl", p2, 2, out[4]}},
     pros -> {{"gl", -p1 - p2, 1, 3},
              {"gl", p1 + p2, 2, 4},
              {"hb", -p1 - p2 + v1, 3, 4},
              {"gl", -v1, 3, 4}}}
  or ExitCode[1] if the file cannot be opened.
dependencies:
  VerbosityRules, ExitCode, Report, Status.
symbols:
  name, hist, legs (in, out), pros.
tags:
  >folds< (inconsistency/overlap in folds).
version:
  2013-05-31 (still Alexey's .sty-file).
description:
  The .dia-file is read and parsed line by line.  For the detection of
  topologies only the propagator (i.e. denominator) structures are of
  impact/importance.
notes:
- Syntactically correct files are assumed.  However, folds inside folds
  should principally be OK.  Due to the  imposed strict regex
  ToExpression[] should never throw any errors.
- The regular expressions used for parsing graphs can be altered easily
  according to any other .sty-file.
- In the QGRAF .sty-file propagator vertex-indices are defined by
    "<vertex_index>*<vertex_degree>+<ray_index>".
- Q: Does QGRAF even produce routings of momenta with coefficients
  different from {-1, 0, 1} (cf. <rdp>)?
- In the output also the information defining the underlying graph is
  included (external vertices have the wrappers in[...] or out[...]).
todo:
- Read the (partial) setup and no. of dias. from the .dia-file (need to
  change gen and possibly .sty-file => next version!).
- Try out .dia-files from the new version of filter (gen-1.6).
*)

(* ---- definition -------------------------------------------------- *)

ClearAll[$GetDiagramsPattern];

(* diagram name *)
$GetDiagramsPattern["d"] =
  "[A-Za-z][0-9]+";

(* FORM variable *)
$GetDiagramsPattern["v"] =
"[A-Za-z][0-9A-Za-z]*";

(* FORM fold: begin *)
$GetDiagramsPattern["b"] = RegularExpression[StringJoin[
  "\\*--#\[ (", $GetDiagramsPattern["d"], ") :"]];

(* expression: vertices *)
$GetDiagramsPattern["vs"] =
  "(\\d+)[\\d\\+\\*]+";

(* external line: in *)
$GetDiagramsPattern["i"] = RegularExpression[StringJoin[
  "cI\\((", $GetDiagramsPattern["v"], "),(\\d+),",
  $GetDiagramsPattern["vs"], ",(", $GetDiagramsPattern["v"], ")\\)"]];

(* external line: out *)
$GetDiagramsPattern["o"] = RegularExpression[StringJoin[
  "cO\\((", $GetDiagramsPattern["v"], "),", $GetDiagramsPattern["vs"],
  ",(\\d+),(", $GetDiagramsPattern["v"], ")\\)"]];

(* expression: momenta *)
$GetDiagramsPattern["ps"] =
  "[\\w\\+\\-\\*\\/]+";

(* internal line *)
$GetDiagramsPattern["p"] = RegularExpression[StringJoin[
  "cP\\((", $GetDiagramsPattern["v"], "),", $GetDiagramsPattern["vs"],
  ",", $GetDiagramsPattern["vs"], ",(", $GetDiagramsPattern["ps"],
  ")\\)"]];

(* FORM fold: end *)
$GetDiagramsPattern["e"] = RegularExpression[StringJoin[
  "\\*--#\] (", $GetDiagramsPattern["d"], ") :"]];

Options[GetDiagrams] =
{Path -> ".",          (* _String *)
 Parallel -> False,    (* cf. $FlagRules *)
 Status -> True,       (* cf. $FlagRules *)
 Verbosity -> False};  (* cf. VerbosityRules *)

GetDiagrams::file = "\
Could not find file named \"`1`\" in \"`2`\".";

GetDiagrams::fold = "\
Warning: Inconsistency or overlap of FORM folds in \"`1` # `2`\".";

GetDiagrams[
  fn_String, nms:{___String}:{},
  opts:OptionsPattern[]] :=
  Module[
    {pt,st,vb, fh, dias = {}, ln = "", nm = "", sl, ls,ps},

    (* -- options -- *)

    {pt, st, vb} = OptionValue[{Path, Status, Verbosity}];

    pt = FileNameJoin[{pt, fn}];
    st = TrueQ[st];
    vb = vb /. VerbosityRules;

    (* -- file: open -- *)

    pt = Quiet[Check[AbsoluteFileName[pt], pt]];
    fh = Quiet[Check[OpenRead[pt], Null]];
    If[fh === Null,
       Message[GetDiagrams::file, fn, pt];
       Abort[]];

    Report[vb, 1, "[GetDiagrams] reading from \n  \"", pt, "\"."];

    (* -- main -- *)

    If[st, Status[
      FrontEnd, "-> Reading \"", nm, "\"...", Temporary -> True]];

    While[
      (ln = Read[fh, String]) =!= EndOfFile,

      (* fold: begin *)
      sl = StringCases[ln, $GetDiagramsPattern["b"] -> "$1", 1];
      If[nm === "" && sl =!= {},
         If[nms =!= {} && FreeQ[nms, sl[[1]]],
            Continue[]];
         nm = sl[[1]];
         ls = ps = {};
         If[st, Status[
           Console, "-> Reading \"", nm, "\"...", Temporary -> True]];
         Report[vb, 2, "Reading \"", nm, "\"..."];
         Continue[]];

      (* fold: outside *)
      If[nm === "",
         Continue[]];

      (* line: external *)
      sl = StringCases[
        ln,
        {$GetDiagramsPattern["i"] -> {"\"$1\"", "$4", "in[$2]", "$3"},
         $GetDiagramsPattern["o"] -> {"\"$1\"", "$4", "$2", "out[$3]"}},
        1];
      If[sl =!= {},
         ls = Append[ls, ToExpression /@ sl[[1]]];
         Report[vb, 3, "External line:\n  ", sl[[1]], "."];
         Continue[]];

      (* line: internal *)
      sl = StringCases[
        ln, $GetDiagramsPattern["p"] -> {"\"$1\"", "$4", "$3", "$2"},
        1];
      If[sl =!= {},
         ps = Append[ps, ToExpression /@ sl[[1]]];
         Report[vb, 3, "Internal line:\n  ", sl[[1]], "."];
         Continue[]];

      (* fold: ends *)
      sl = StringCases[ln, $GetDiagramsPattern["e"] -> "$1", 1];
      If[sl =!= {},
         If[nm =!= sl[[1]],
            Message[GetDiagrams::fold, fn, nm];
            Break[]];
         AppendTo[dias, Diagram[
           name -> nm, hist -> {"GetDiagrams", pt <> " # " <> nm},
           legs -> ls, pros -> ps]];
         nm = "";
         Report[
           vb, 3, Length[ls], " internal, ", Length[ps], " external."]]
    ];

    (* -- file: close -- *)

    Close[fh];

    If[st, Status[
      All, "Read ", Evaluate @ Length[dias], " diagrams.",
      Temporary -> False]];

    Report[vb, 2, "Read ", Length[dias], " diagrams."];

    dias];

GetDiagrams[fn_String, nm_String, opts:OptionsPattern[]] :=
  GetDiagrams[fn, {nm}, opts];

GetDiagrams[
  fns:{__String}, nms_:{},
    opts:OptionsPattern[]] :=
  Join @@ (GetDiagrams[#, nms, opts] & /@ fns);

GetDiagrams[__] :=
  (Message[GetDiagrams::usage];
   Abort[]);

(* ---- samples ----------------------------------------------------- *)

(* sample input:
*--#[ D1 :

* vertices:
  cV(3,gl,gl,gl,1*5+1,1*5+2,1*5+3,p1,p2,-p1-p2) *
  cV(3,gl,gl,gl,2*5+1,2*5+2,2*5+3,-p1,-p2,p1+p2) *
  cV(3,gl,gl,hb,3*5+1,3*5+2,3*5+3,p1+p2,-v1,v1-p1-p2) *
  cV(3,gl,gl,hb,4*5+1,4*5+2,4*5+3,-p1-p2,v1,-v1+p1+p2) *

* propagators:
  cP(gl,1*5+3,3*5+1,-p1-p2) *
  cP(gl,2*5+3,4*5+1,p1+p2) *
  cP(hb,3*5+3,4*5+3,v1-p1-p2) *
  cP(gl,3*5+2,4*5+2,-v1) *

* legs:
  cI(gl,1,1*5+1,p1) *
  cI(gl,2,1*5+2,p2) *
  cO(gl,2*5+1,3,p1) *
  cO(gl,2*5+2,4,p2) *

...

*--#] D1 :
*)

(* sample call:
GetDiagrams["<some_path>/1.gr.dia"];
GetDiagrams["1.gr.dia", Path -> "<some_path>"];
*)

(* sample output:
{{name -> "D1",
  hist -> {GetDiagrams -> "<some_path>/1.gr.dia", name -> "D1"},
  legs -> {{"gl", p1, in[1], 1},
           {"gl", p2, in[2], 1},
           {"gl", p1, 2, out[3]},
           {"gl", p2, 2, out[4]}},
  pros -> {{"gl", -p1 - p2, 1, 3},
           {"gl", p1 + p2, 2, 4},
           {"hb", -p1 - p2 + v1, 3, 4},
           {"gl", -v1, 3, 4}}},
 ...}
*)

(* --- -------------------------------------------------------------- *)

(* TODO:
- update description, samples
- handle Parallel option
*)

(*(*(*(*(*(*(*(**)*)*)*)*)*)*)*)

(* --- GetTopologies ------------------------------------------------ *)

ClearAll[$GetTopologiesPattern];

$GetTopologiesPattern["v"] =
  "[A-Za-z][0-9A-Za-z]*";

$GetTopologiesPattern["d"] = RegularExpression[StringJoin[
  "#define ([pkd])(", $GetTopologiesPattern["v"], ") \\\"(.*?)\\\""]];

$GetTopologiesPattern["b"] = RegularExpression[StringJoin[
  "#procedure ([ecs])(", $GetTopologiesPattern["v"], ")(\\((",
  $GetTopologiesPattern["v"], ")\\))?"]];

$GetTopologiesPattern["r"] = RegularExpression[StringJoin[
  "id ([^=]+)=([^=]+);"]];

$GetTopologiesPattern["n"] = RegularExpression[StringJoin[
  "(", $GetTopologiesPattern["v"], ")\\?neg0_"]];

$GetTopologiesPattern["e"] =
  "#endprocedure";

Options[GetTopologies] =
{Path -> ".",          (* _String *)
 Parallel -> False,    (* True, False/... *)
 Status -> True,       (* True, False/... *)
 Verbosity -> False};  (* cf. VerbosityRules *)

GetTopologies::name = "\
Warning: Inconsistent topology names in \"`1`\": \"`2`\", \"`3`\".";

GetTopologies::procedure = "\
Warning: Inconsistency or overlap of FORM procedures in \"`1`\": \
\"`2`\", \"`3`\".";

GetTopologies[
  fn_String, nms:{___String}:{},
  opts:OptionsPattern[]] :=
  Module[



    {pt,st,vb, ft,fh, nm,pr,sc,scs, ln, sel, dec,def, scpr,fs,rl,ct,zr, top},

    {pt, st, vb} = OptionValue[{Path, Status, Verbosity}];

    pt = pt;                                                     (* TODO: Directory[]? *)
    st = TrueQ[st];                                              (* TODO? *)
    vb = vb /. VerbosityRules;

    (* --  -- *)

    ft = FileNameJoin[{pt, fn}] // ExpandFileName;                      (* TODO: AbsoluteFileName[] *)

    fh = OpenRead[ft];                                           (* TODO: Check *)

    nm = "";
    pr = sc = Null;
    scs = {};

    While[True,

          ln = Read[fh, String];

          (* reached end of file *)
          If[ln === EndOfFile, Break[]];

          (* ignore FORM comments *)
          If[StringTake[ln, 1] === "*",
             If[vb,
                Print["comment: ", ln]];
             Continue[]];

          (* declaration of momenta and factor symbols *)
          sel = StringCases[ln, $GetTopologiesPattern["d"] -> {"$2", "$1", "$3"}];
          If[sel =!= {},
             If[nm === "", nm = sel[[1, 1]]];
             If[nm =!= sel[[1, 1]], Message[GetTopologies::name, nm, sel[[1, 1]]]];
             dec[sel[[1, 2]]] = ToExpression["{" <> sel[[1, 3]] <> "}"];
             If[vb,
                Print["declaration: ", sel[[1, 2]], " -- ", dec[sel[[1, 2]]]]];
             Continue[]];

          (* procedure: begin *)
          sel = StringCases[ln, $GetTopologiesPattern["b"] -> {"$2", "$1", "$4"}];
          If[sel =!= {},
             If[nm === "", nm = sel[[1, 1]]];
             If[nm =!= sel[[1, 1]], Message[GetTopologies::name, nm, sel[[1, 1]]]];
             If[pr =!= Null, Message[GetTopologies::procedure, pr <> nm, sel[[1, 2]] <> nm]];
             {pr, sc} = sel[[1, 2 ;; 3]];
             def[pr] = {};
             sc = ToExpression[sc];
             AppendTo[scs, sc];
             If[vb,
                Print["procedure begin: ", pr, ", scale: ", sc]];
             Continue[]];

          (* identities *)
          sel = StringCases[ln, $GetTopologiesPattern["r"] -> Rule["$1", "$2"]];
          If[sel =!= {},
             If[pr === Null, Continue[]];  (* assure if within a procedure and def[pr] existent *)
             sel = sel[[1]];
             sel = StringReplace[#, {"." -> "*", "`" -> "", "'" -> "", "acc" -> "",
                                     $GetTopologiesPattern["n"] -> "$1_ /; $1 <= 0",
                                     "?" -> "_"}] & /@ sel;  (* TODO: add options *)
             sel = ToExpression[#, TraditionalForm] & /@ sel;
             AppendTo[def[pr], sel];
             If[vb,
                Print["identity: ", sel]];
             Continue[]];

          (* procedure: end *)
          sel = StringCases[ln, $GetTopologiesPattern["e"]];
          If[sel =!= {},
             If[vb,
                Print["procedure end: ", pr]];
             pr = Null];

        ];

    Close[fh];

    (* --  -- *)

    scpr = ScalarProducts[dec["p"], dec["k"]];

    fs = Select[def["e"], MemberQ[dec["d"], #[[1]]] & ];

    (* bring >facs< into order of d<TOP> *)
    ord = Position[First /@ fs, #][[1, 1]] & /@ dec["d"];  (* TODO: catch -> logic error *)
    fs = fs[[ord]];

    If[vb,
       Print["order: ", ord]];

    rl = Select[def["c"], MemberQ[scpr, #[[1]]] & ];

    ct = Union[Complement[def["e"], fs],
               Complement[def["c"], rl]];

    zr = Select[def["s"], Head[#[[1]]] === ToExpression[nm] & ];
    zr = Select[zr, #[[2]] === 0 & ];
    zr = List @@ #[[1]] & /@ zr;
    zr = zr /. Condition -> dd /. dd[___] -> 0 /. Pattern -> dd /. dd[___] -> 1;
    zr = Pick[Range[Length[#]], #, 1] & /@ zr;

    Topology[
      name -> nm,
      hist -> {"GetTopologies", ft},
      facs -> fs,
      scps -> rl,
      rels -> {},
      (*
      zero -> zr,
      *)
      setp ->
        Setup[Externals -> dec["p"],
              Internals -> dec["k"],
              Constants -> Union[DeleteCases[scs, Null]],
              Constraints -> ct]]];

GetTopologies[fn_String, nm_String, opts:OptionsPattern[]] :=
  GetTopologies[fn, {nm}, opts];

GetTopologies[
  fns:{__String}, nms_:{},
    opts:OptionsPattern[]] :=
  Module[
    {pt,st,vb, tops},

    (* -- options -- *)

    {pt, st, vb} = OptionValue[{Path, Status, Verbosity}];

    pt = FileNameJoin[{pt, fn}];
    st = TrueQ[st];
    vb = vb /. VerbosityRules;

    tops = GetTopologies[#, nms, opts] & /@ fns;

    If[st, Status[
      All, "Read ", Evaluate @ Length[tops], " topologies:\n  \"",
      Sequence @@ Riffle[name /. tops, "\",\n  \""], "\".",
      Temporary -> False]];

    tops];

GetTopologies[__] :=
  (Message[GetTopologies::usage];
   Abort[]);

(* TODO:
- ToExpression -> Check
- folds (parse + access)?
- multi-line identities (check for ";")
- masses by Complement[Variables[facs], {vs, xs}]
*)

(* --- -------------------------------------------------------------- *)

(* TODO:
- "<file # name>" aliases
- ExtractSetup
- ApplySetup
*)

(* ------------------------------------------------------------------ *)

End[];

EndPackage[];

(* ------------------------------------------------------------------ *)
