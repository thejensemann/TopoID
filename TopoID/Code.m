(* -- "Code.m": FORM Code for Processing Topologies ----------------- *)

(* --- provided functions:                                              TODO

FORMTopologyHeader[] -> <code>
-- comment stating TopoID version and current date

FORMTopologyComment[<top>, [<set>]] -> <code>
-- comment stating the factor/line definitions

FORMTopologyDefine[<top>, [<set>], [opts]] -> <code>
-- preprocessor statements defining needed variables

FORMTopologyFactors[<top>, [<set>]] -> <code>
-- code to rewrite function as product of factors

FORMTopologyFunction[<top>, [<set>]] -> <code>
-- code to rewrite product of factors as function

FORMTopologyExpand[<top>, [<set>]] -> <code>
-- code to expand factors in terms of scalar products

FORMTopologyReduce[<top>, [<set>]] -> <code>
-- code to reduce scalar products in terms of factors

FORMTopologyZeros[<top>, [<set>]] -> <code>
-- code to discard vanishing sub-topologies

FORMTopologySymmetries[<top>, [<set>], [<lvl>]] -> <code>
-- code to apply symmetries in (sub-)topologies

FORMTopologySimplify[<top>, [<set>], [opts]] -> <code>
-- code to trigger various simplifications

FORMTopology[<top>, [<set>], [opts]] -> <code>
-- complete code for a basic topology


FORMTopologyApart[<top>, [<set>]] -> <code>
-- code implementing partial fraction decomposition

FORMTopologyMapping[
  <map(s)>, <src>, [<trg(s)>], [<set>], [opts]] -> <code>
-- code performing mapping to independents

FORMTopologyMain[<map(s)>, <top>, [<set>], [opts]]
-- main procedure steering the code

FORMTopologyProcess[<map(s)>, <src(s)>, [<trg(s)>], [opts]] -> <code>
-- complete code for a generic topology


TODO

*)

(* --- package begin ------------------------------------------------ *)

Unprotect["TopoID`Code`*"];

ClearAll["TopoID`Code`*", "TopoID`Code`Private`*"];

BeginPackage[
  "TopoID`Code`",
  {"TopoID`Common`", "TopoID`System`",  (* TODO *)

   "TopoID`Setup`",
   "TopoID`Topology`",
   "TopoID`Mapping`",

   "TopoID`Text`",
   "TopoID`FORM`",

   "TopoID`Object`"}];

(* needed for basic topologies *)
{MM, M2ep, $FORMTopologyBaseScaleFunction,
 $FORMTopologyIncludeFunction, $FORMTopologyLoadingFunction,
 FORMTopologyHeader,
 $FORMTopologyCommentFunction, FORMTopologyComment, FORMTopologyDefine,
 FORMTopologyFactors, FORMTopologyFunction,
 FORMTopologyExpand, FORMTopologyReduce,
 FORMTopologyZeros, FORMTopologySymmetries,
 $FORMTopologySimplifyZeros, $FORMTopologySimplifySymmetries,
 $FORMTopologySimplifyVariables, FORMTopologySimplify,
 FORMTopology};

(* in addition for generic topologies *)
{FORMTopologyApart,
 FORMTopologyMapping, FORMTopologyMappings,
 $FORMTopologyMainMethods, FORMTopologyMain,
 FORMTopologyProcess};

(* extension for EXP/MATAD *)
{FORMTopologyMATAD,
 FORMTopologyMomentaShifts,
 FORMDiaToTop,
 FORMFacToTop,
 FORMFacToZero};
(* ^-- TODO *)

Begin["`Private`"];

(* --- BaseScale, ... ----------------------------------------------- *)

MM::usage = "\
Symbol used throughout the generated FORM code as preprocessor \
variable representing the squared base scale of the problem.  That is, \
it has mass dimension +2.
The way this base scale is chosen can be adjusted via the option \
[BaseScaleFunction] of several FORM code generation routines.";

M2ep::usage = "\
Symbol used throughout the generated FORM code as preprocessor \
variable representing the dimensional transmutation factor for each \
loop integration involving the base scale `MM' of the problem.  It is \
defined as (mu^2/`MM'^2)^ep.
The way this base scale is chosen can be adjusted via the option \
[BaseScaleFunction] of several FORM code generation routines.";

(* helper: get base scale; #1: TopologyPattern[], #2: SetupPattern[] *)
$FORMTopologyBaseScaleFunction =
  First[xs /. #2] & ;

(* --- Include, Loading, ... ---------------------------------------- *)

$FORMTopologyIncludeFunction =
  StringJoin["#include `ROOT'/def/", #, ".def\n"] & ;

(* Include as FORM code. *)
$FORMTopologyLoadingFunction[1] =
  StringJoin["#include `ROOT'/tab/", #, ".inx\n"] & ;

(* Load FORM ".sav"-file. *)
$FORMTopologyLoadingFunction[2] =
  StringJoin["load `ROOT'/tab/", #, ".sav\n"] & ;

(* Use an elsewhere defined command. *)
$FORMTopologyLoadingFunction[3] =
  StringJoin["#call laporta(", #, ")\n"] & ;

(* Use FORM tablebases... *)

(* --- FORMTopologyHeader ------------------------------------------- *)

FORMTopologyHeader::usage = "\
FORMTopologyHeader[] returns a FORM comment stating the used version \
of TopoID and the date of code generation.";

(* main *)
FORMTopologyHeader[] := FORMComment[
  " ",
  StringJoin[
    "Generated by TopoID-", $TopoIDVersion, " (", $TopoIDDate, ") on ",
    DateText[], "."],
  " ",
  "  Note: Delete this comment on modification.",
  " "];

(* trap *)
FORMTopologyHeader[___] :=
  (Message[FORMTopologyHeader::usage];
   Abort[]);

(* --- FORMTopologyComment ------------------------------------------ *)

(* helper: factor/line definitions from strings; #1: numbers,
  #2: >facs<, #3: >pros< *)

(* number, symbol, denominator *)
$FORMTopologyCommentFunction[1] = StringJoin[
  "  ", #1,
  ":## ", #2[[1]],
  ",## ", #2[[2]]] & ;

(* number, symbol, label/mass, momenta flow *)
$FORMTopologyCommentFunction[2] = StringJoin[
  "  ", #1,
  ":## ", #2[[1]],
  "## (", #3[[1]], ")",
  ",## ", #3[[2]]] & ;

(* number, symbol, label/mass, momenta flow, vertices *)
$FORMTopologyCommentFunction[3] = StringJoin[
  "  ", #1,
  ":## ", #2[[1]],
  "## (", #3[[1]], ")",
  ",## ", #3[[2]],
  ",## ", #3[[3]], " --## ", #3[[4]]] & ;

(* -- *)

FORMTopologyComment::usage = "\
FORMTopologyComment[<top>, [<set>]] generates FORM comments stating the \
definitions of topology lines or factors for <top>, optionally \
considering setup [<set>].";

(* main: "Graph" *)
FORMTopologyComment[
  top:TopologyPattern["Graph"], ___] :=
  Module[
    {fs,ps, ns},
    {fs, ps} = {facs, pros} /. top;
    (* replace irreducible numerators *)
    ps = ps /. Null -> "SP";
    {fs, ps} = Map[FORMForm, {fs, ps}, {3}];
    ns = ToString /@ Range[Length[fs]];
    FORMComment[
      "topology line definitions:",
      StringReplace[
        AdjustColumns[
          StringJoin[Riffle[MapThread[
            $FORMTopologyCommentFunction[3], {ns, fs, ps}], "\n"]],
          Offset -> 0, RecordSeparators -> "##"],
        "##" -> ""]]];

(* main: with setup *)
FORMTopologyComment[
  top:TopologyPattern[], set:SetupPattern[]] :=
  Module[
    {fs, tms,tfs, ps, ns},
    fs = facs /. top;
    (* reconstruct masses, momenta flows *)
    tms = TopologyMasses[top, set];
    tfs = TopologyMomentaFlows[top, set];
    ps = Transpose[{tms, tfs}];
    {fs, ps} = Map[FORMForm, {fs, ps}, {3}];
    ns = ToString /@ Range[Length[fs]];
    FORMComment[
      "topology line definitions:",
      StringReplace[
        AdjustColumns[
          StringJoin[Riffle[MapThread[
            $FORMTopologyCommentFunction[2], {ns, fs, ps}], "\n"]],
          Offset -> 0, RecordSeparators -> "##"],
        "##" -> ""]]];

(* main: default *)
FORMTopologyComment[
  top:TopologyPattern[]] :=
  Module[
    {fs, ns},
    fs = facs /. top;
    fs = Map[FORMForm, fs, {2}];
    ns = ToString /@ Range[Length[fs]];
    FORMComment[
      "topology line definitions:",
      StringReplace[
        AdjustColumns[
          StringJoin[Riffle[MapThread[
            $FORMTopologyCommentFunction[1], {ns, fs}], "\n"]],
          Offset -> 0, RecordSeparators -> "##"],
        "##" -> ""]]];

(* overload: "Setup" *)
FORMTopologyComment[top:TopologyPattern["Setup"]] :=
  FORMTopologyComment[top, setp /. top];

(* trap *)
FORMTopologyComment[___] :=
  (Message[FORMTopologyComment::usage];
   Abort[]);

(* --- FORMTopologyDefine ------------------------------------------- *)

Options[FORMTopologyDefine] =
{BaseScaleFunction -> $FORMTopologyBaseScaleFunction};
(* _Function *)

FORMTopologyDefine::usage = "\
FORMTopologyDefine[<top>, [<set>], [opts]] generates FORM preprocessor \
define statements for external and internal momenta, topology factor \
symbols and used variables of <top>.";

(* main *)
FORMTopologyDefine[
  top:TopologyPattern[], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {f, bs, nm, ss, vs},
    f = {NumeratorSymbolQ[#], StringLength[ToString[#]]} & ;
    bs = OptionValue[BaseScaleFunction];
    (* name *)
    nm = name /. top;
    (* ordered symbols *)
    ss = SortBy[First /@ (facs /. top), f];
    (* appearing variables: RHS of rules, FORMSymbol[] *)
    vs = Join[
      DeleteCases[Variables[Last /@ (rs /. set)], bs[top, set]],
      Cases[
        Variables[Join[
          Last /@ (facs /. top), Last /@ (scps /. top /. scps -> {})]],
        FORMSymbol[_]]];
    (* result *)
    FORMCode[
      FORMDefine["top" -> nm],
      (* external momenta *)
      FORMDefine["p" <> nm -> FORMVariables[ps /. set]],
      (* internal momenta *)
      FORMDefine["k" <> nm -> FORMVariables[ks /. set]],
      (* factor symbols *)
      FORMDefine["d" <> nm -> FORMVariables[ss]],
      (* variable symbols *)
      FORMDefine["v" <> nm -> FORMVariables[vs]]]];

(* overload: "Setup" *)
FORMTopologyDefine[top:TopologyPattern["Setup"]] :=
  FORMTopologyDefine[top, setp /. top];

(* trap *)
FORMTopologyDefine[___] :=
  (Message[FORMTopologyDefine::usage];
   Abort[]);

(* --- FORMTopologyFactors ------------------------------------------ *)

FORMTopologyFactors::usage = "\
FORMTopologyFactors[<top>, [<set>]] generates FORM code performing the \
notation change from function to factor form for topology <top>.";

(* main *)
FORMTopologyFactors[
  top:TopologyPattern[], set:SetupPattern[]] :=
  Module[
    {fs,es, ls},
    (* factor, exponent symbols *)
    fs = FORMForm /@ First /@ (facs /. top);
    es = MapIndexed["a" <> ToString[#2[[1]]] & , fs];
    (* number of loops *)
    ls = ToString[nk /. set];
    (* result *)
    FORMProcedure["f" <> (name /. top), "MM", "M2ep", FORMCode[
      FORMComment["write as factors"],
      FORMIdentify[Rule[
        StringJoin[
          name /. top, "(", Riffle[# <> "?" & /@ es, ","], ")\n "],
        StringJoin[
          name /. top, "*M2ep^(-", ls, ")*MM^(-2*", ls,
          " - " <> # & /@ es, ")\n    ",
          MapThread["*" <> #1 <> "^(-" <> #2 <> ")" & , {fs, es}]]]]]]];

(* overload: "Setup" *)
FORMTopologyFactors[top:TopologyPattern["Setup"]] :=
  FORMTopologyFactors[top, setp /. top];

(* trap *)
FORMTopologyFactors[___] :=
  (Message[FORMTopologyFactors::usage];
   Abort[]);

(* --- FORMTopologyFunction ----------------------------------------- *)

FORMTopologyFunction::usage = "\
FORMTopologyFunction[<top>, [<set>]] generates FORM code performing \
the notation change from factor to function form for topology <top>.";

(* main *)
FORMTopologyFunction[
  top:TopologyPattern[], set:SetupPattern[]] :=
  Module[
    {fs,es, ls},
    (* factor, exponent symbols *)
    fs = FORMForm /@ First /@ (facs /. top);
    es = MapIndexed["a" <> ToString[#2[[1]]] & , fs];
    (* number of loops *)
    ls = ToString[nk /. set];
    (* result *)
    FORMProcedure["g" <> (name /. top), "MM", "M2ep", FORMCode[
      FORMComment["write as function"],
      FORMIdentify[Rule[
        StringJoin[
          name /. top, "*",
          Riffle[MapThread[#1 <> "^" <> #2 <> "?" & , {fs, es}], "*"],
          "\n "],
        StringJoin[
          "M2ep^(+", ls, ")*MM^(+2*", ls, " + " <> # & /@ es,
          ")\n    *", name /. top, "(", Riffle["-" <> # & /@ es, ","],
          ")"]]]]]];

(* overload: "Setup" *)
FORMTopologyFunction[top:TopologyPattern["Setup"]] :=
  FORMTopologyFunction[top, setp /. top];

(* trap *)
FORMTopologyFunction[___] :=
  (Message[FORMTopologyFunction::usage];
   Abort[]);

(* --- FORMTopologyExpand ------------------------------------------- *)

Options[FORMTopologyExpand] =
{BaseScaleFunction -> $FORMTopologyBaseScaleFunction};
(* _Function *)

FORMTopologyExpand::usage = "\
FORMTopologyExpand[<top>, [<set>]] returns FORM code expanding \
topology factor symbols of <top> in terms of appearing scalar \
products.";

(* main *)
FORMTopologyExpand[
  top:TopologyPattern[], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {bs,sr, nm, rl, ct},
    (* base scale replacement *)
    bs = OptionValue[BaseScaleFunction];
    sr = bs[top, set] -> MM;
    (* name *)
    nm = name /. top;
    (* rewrite relations *)
    rl = FORMIf["match(" <> nm <> ")", ToFORMCodeString[
      "\n  ", FORMIdentify[Factor[#]]]] &
        /@ ToDotProducts[facs /. top /. sr, vs /. set];
    (* rewrite constraints, ignore mass assignments *)
    ct = FORMIdentify[Factor[#]] & /@ ToDotProducts[
      DeleteCases[cs /. set, m[_] -> _] /. sr, vs /. set];
    (* result *)
    FORMProcedure["e" <> nm, MM, FORMCode[
      FORMComment["expansion of factors"],
      {#, ".sort\n"} & /@ rl,
      If[ct =!= {},
         {FORMComment["kinematic constraints"],
          ct,
          ".sort\n"},
         {}]]]];

(* overload: "Setup" *)
FORMTopologyExpand[
  top:TopologyPattern["Setup"], opts:OptionsPattern[]] :=
  FORMTopologyExpand[top, setp /. top, opts];

(* trap *)
FORMTopologyExpand[___] :=
  (Message[FORMTopologyExpand::usage];
   Abort[]);

(* --- FORMTopologyReduce ------------------------------------------- *)

Options[FORMTopologyReduce] =
{BaseScaleFunction -> $FORMTopologyBaseScaleFunction};
(* _Function *)

FORMTopologyReduce::usage = "\
FORMTopologyReduce[<top>, [<set>], [opts]] returns FORM code reducing \
appearing scalar products in terms of topology factor symbols of \
<top>.";

(* main *)
FORMTopologyReduce[
  top:TopologyPattern["Solve"], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {bs,sr, nm, rl, ct},
    (* base scale replacement *)
    bs = OptionValue[BaseScaleFunction];
    sr = bs[top, set] -> MM;
    (* name *)
    nm = name /. top;
    (* rewrite relations *)
    rl = FORMIf["match(" <> nm <> ")", ToFORMCodeString[
      "\n  ", FORMIdentify[Factor[#]]]] &
        /@ ToDotProducts[scps /. top /. sr, vs /. set];
    (* rewrite constraints, ignore mass assignments *)
    ct = FORMIdentify[Factor[#]] & /@ ToDotProducts[
      DeleteCases[cs /. set, m[_] -> _] /. sr, vs /. set];
    (* result *)
    FORMProcedure["c" <> nm, MM, FORMCode[
      FORMComment["reduction of scalar products"],
      {#, ".sort\n"} & /@ rl,
      If[ct =!= {},
         {FORMComment["kinematic constraints"],
          ct,
          ".sort\n"},
         {}]]]];

(* overload: "Setup" *)
FORMTopologyReduce[
  top:TopologyPattern["Solve", "Setup"], opts:OptionsPattern[]] :=
  FORMTopologyReduce[top, setp /. top, opts];

(* trap *)
FORMTopologyReduce[___] :=
  (Message[FORMTopologyReduce::usage];
   Abort[]);

(* --- FORMTopologyZeros -------------------------------------------- *)

FORMTopologyZeros::usage = "\
FORMTopologyZeros[<top>, [<set>]] returns FORM code discarding \
vanishing sub- topologies (due to, e.g., scalelessness, boundary \
conditions or cut-conditions).";

(* default: no "Zero" *)
FORMTopologyZeros[___, top:TopologyPattern[], ___] /;
!MatchQ[zero /. top, GroupPattern[]] || (zero /. top) === {} :=
  FORMProcedure["z" <> (name /. top), FORMCode[
    FORMComment["no vanishing sub-topologies"]]];

(* case: factor form *)
FORMTopologyZeros[
  "fact", top:TopologyPattern["Zero"]] :=
  Module[
    {f, fs,zs},
    f = "(count(" <> # <> ",1) >= 0)" & ;
    fs = ToString /@ First /@ (facs /. top);
    zs = f /@ Complement[fs, fs[[#]]] & /@ (zero /. top);
    FORMProcedure["z" <> (name /. top), FORMCode[
      FORMComment["vanishing sub-topologies"],
      FORMIf[StringJoin[
        Riffle[#, " &&\n    "]], "\n  discard;\n"] & /@ zs]]];

(* case: function form *)
FORMTopologyZeros[
  "func", top:TopologyPattern["Zero"]] :=
  Module[
    {f, es,zs},
    f = # <> "neg0_" & ;
    fs = Range[Length[facs /. top]];
    es = "a" <> ToString[#] <> "?" & /@ fs;
    zs = MapAt[f, es, List /@ Complement[fs, #]] & /@ (zero /. top);
    FORMProcedure["z" <> (name /. top), FORMCode[
      FORMComment["vanishing sub-topologies"],
      FORMIdentify[StringJoin[
        name /. top, "(", Riffle[#, ","], ")"] -> 0] & /@ zs]]];

(* main: select by linear dependency *)
FORMTopologyZeros[top:TopologyPattern["Zero"], set:SetupPattern[]] :=
  FORMTopologyZeros[
    If[TopologyDependentQ[top, set], "fact", "func"], top];

(* overload: "Setup" *)
FORMTopologyZeros[top:TopologyPattern["Setup"]] :=
  FORMTopologyZeros[top, setp /. top];

(* trap *)
FORMTopologyZeros[___] :=
  (Message[FORMTopologyZeros::usage];
   Abort[]);

(* --- FORMTopologySymmetries --------------------------------------- *)

FORMTopologySymmetries::usage = "\
FORMTopologySymmetries[<top>, [<set>], [<lvl>]] returns FORM code \
performing symmetrization of integrals also in sub-topologies.";

FORMTopologySymmetries::level = "\
Warning: No valid level specification for subsets given by `1`, the \
default will be used.
Use one of the following (symbols denote positive integers, nf is the \
number of topology factors):
- All/Infinity -- all levels (equivalent to {1, nf}),
- n -- down to n elements (equivalent to {n, nf}),
- {n} -- exactly n elements,
- {nmin, nmax/Infinity} -- between nmin and nmax elements,
- {nmin, nmax/Infinity, dn} -- between nmin and nmax elements with \
distance dn.";

(* default: no "Symm" *)
FORMTopologySymmetries[___, top:TopologyPattern[], ___] /;
!MatchQ[symm /. top, {GroupPattern[]...}] || (symm /. top) === {} :=
  FORMProcedure["y" <> (name /. top), FORMCode[
    FORMComment["no symmetries"]]];

(* common: without level *)
FORMTopologySymmetries[
  "main", top:TopologyPattern["Symm"]] :=
  Module[
    {f,g, fs, ss},
    f = StringJoin[Riffle[#, "\\\\\\,"]] & ;
    g = StringJoin[Riffle[f /@ #, "\\,\\\n            "]] & ;
    fs = FORMForm /@ First /@ (facs /. top);
    ss = fs[[#]] & /@ # & /@ (symm /. top);
    FORMRepeat["", "#call fsymm(" <> g[#] <> ")\n" & /@ ss]];           (* TODO: "" workaround *)

(* common: with level *)
FORMTopologySymmetries[
  "main", top:TopologyPattern["Symm"], lvl_] :=
  Module[
    {f,g,h, fs, nf, lv, ss},
    f = StringJoin[Riffle[#, "\\\\\\,"]] & ;
    g = StringJoin[Riffle[f /@ #, "\\,\\\n            "]] & ;
    h = Function[s, FORMHIf[
      StringJoin[
        "`sym", name /. top, "' <= ", ToString[Length[Part[s, 1, 1]]]],
      "#call fsymm(" <> g[#] <> ")\n" & /@ s]];
    fs = FORMForm /@ First /@ (facs /. top);
    (* check: level *)
    nf = Length[fs];
    lv = lvl /. If[
      Head[lvl] === List,
      {All | Infinity -> nf},
      {All | Infinity -> {1, nf}, n_Integer -> {n, nf}}];
    If[!MatchQ[lv, {__Integer}] || Length[lv] > 3 ||
         Or @@ Negative /@ lv,
       Message[FORMTopologySymmetries::level, lvl];
       lv = {1, nf}];
    lv = Reverse[Range @@ lv];
    (* adapt notation *)
    ss = fs[[#]] & /@ # & /@ (symm /. top);
    (* group by level *)
    ss = Function[l, Select[ss, Length[First[#]] === l & ]] /@ lv;
    (* delete empty levels *)
    ss = DeleteCases[ss, {}];
    (* result *)
    FORMRepeat["\n", Riffle[h /@ ss, "\n"], "\n"]];

(* case: factor form *)
FORMTopologySymmetries[
  "fact", top:TopologyPattern["Symm"], lvl:Elective[_]] :=
  FORMProcedure["y" <> (name /. top), FORMCode[
    FORMComment["symmetries"],
    FORMTopologySymmetries["main", top, lvl]]];

(* case: function form *)
FORMTopologySymmetries[
  "func", top:TopologyPattern["Symm"], lvl:Elective[_]] :=
  FORMProcedure["y" <> (name /. top), FORMCode[
    FORMRedefine["top", name /. top],
    FORMComment["change notation"],
    "#call f" <> (name /. top) <> "(1,1);\n",
    FORMComment["symmetries"],
    FORMIf["match(" <> (name /. top) <> ")", FORMCode[
      "", FORMTopologySymmetries["main", top, lvl]]],                   (* TODO: "" workaround *)
    FORMComment["change notation"],
    "#call g" <> (name /. top) <> "(1,1);\n"]];

(* main: select by linear dependency *)
FORMTopologySymmetries[
  top:TopologyPattern["Symm"], set:SetupPattern[], lvl:Elective[_]] :=
  FORMTopologySymmetries[
    If[TopologyDependentQ[top, set], "fact", "func"], top, lvl];

(* overload: "Setup" *)
FORMTopologySymmetries[top:TopologyPattern["Setup"], lvl:Elective[_]] :=
  FORMTopologySymmetries[top, setp /. top, lvl];

(* trap *)
FORMTopologySymmetries[___] :=
  (Message[FORMTopologySymmetries::usage];
   Abort[]);

(* --- FORMTopologySimplify ----------------------------------------- *)

$FORMTopologySimplifyZeros = FORMCode[
  FORMComment["discard vanishing sub-topologies"],
  If[#2 <= 0, FORMComment, FORMCode] @ StringJoin[
    "#call z", name /. #1, "\n",
    ".sort\n"]] & ;

$FORMTopologySimplifySymmetries = FORMCode[
  FORMComment["apply symmetries"],
  If[#2 <= 0, FORMComment, FORMCode] @ StringJoin[
    "#call y", name /. #1, "\n",
    ".sort\n"]] & ;

$FORMTopologySimplifyVariables = Block[
  {vrs = Cases[
    Variables[
      Join[Last /@ (facs /. #1), Last /@ (scps /. #1 /. scps -> {})]],
    FORMSymbol[_]]},
  FORMCode[If[
    vrs =!= {},
    {FORMComment["substitute variables"],
     If[#2 <= 0, FORMComment, FORMCode] @@
     {FORMReplace[Function[r, r -> (r /. FORMSymbol[x_] -> x)] /@ vrs],
      ".sort\n"}}, {}]]] & ;

MethodRules[FORMTopologySimplify] =
{Rule["zero", i_Integer] :>
   ($FORMTopologySimplifyZeros[#, i] & ),
 Rule["symm", i_Integer] :>
   ($FORMTopologySimplifySymmetries[#, i] & ),
 Rule["vars", i_Integer] :>
   ($FORMTopologySimplifyVariables[#, i] & ),
 x_ :>
   (Message[MethodRules::norule, x];
    (FORMComment["!!! MISSING RULE !!!"] & ))};

Options[FORMTopologySimplify] =
{Method -> {"zero" -> 1, "symm" -> 1, "vars" -> 1}};

FORMTopologySimplify::usage = "\
FORMTopologySimplify[<top>, [<set>], [opts]] returns FORM code \
performing or triggering various simplifications (e.g. discarding \
vanishing or symmetrizing equal (sub-)topologies).";

FORMTopologySimplify::method = "\
Warning: Invalid option value(s) `1` for [Method] will be ignored.
Possible assignments are of the form _String -> _Integer.";

FORMTopologySimplify::error = "\
Warning: Error(s) occured during the call of a function specified via \
the [Method] option.";

FORMTopologySimplify[
  top:TopologyPattern[], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {me, pk, fc},
    (* check: Method *)
    me = OptionValue[Method];
    If[Head[me] =!= List,
       me = {me}];
    pk = MatchQ[#, _String -> _Integer] & /@ me;
    If[!And @@ pk,
       Message[FORMTopologySimplify::method, Pick[me, Not /@ pk]];
       me = Pick[me, pk]];
    me = # /. MethodRules[FORMTopologySimplify] & /@ me;
    (* generate, check calls *)
    fc = Check[
      #[top, set],
      Message[FORMTopologySimplify::error];
      FORMComment["!!! CODE GENERATION ERROR !!!"]] & /@ me;
    (* default *)
    If[fc === {}, fc = FORMComment["no simplifications"]];
    (* result *)
    FORMProcedure["s" <> (name /. top), FORMCode[fc]]];

(* overload: "Setup" *)
FORMTopologySimplify[
  top:TopologyPattern["Setup"], opts:OptionsPattern[]] :=
  FORMTopologySimplify[top, setp /. top, opts];

(* trap *)
FORMTopologySimplify[___] :=
  (Message[FORMTopologySimplify::usage];
   Abort[]);

(* N.B.:
- Calls for various simplification procedures can be inserted via
  functions listed in [Method] that are applied to <top> and <set>.
*)

(* --- FORMTopology ------------------------------------------------- *)

MethodRules[FORMTopology] =
{Rule["zero", i_Integer] :> Rule[
  $FORMTopologySimplifyZeros[#, i] & ,
  FORMTopologyZeros["func", #1] & ],
 Rule["symm", i_Integer] :> Rule[
   $FORMTopologySimplifySymmetries[#, i] & ,
   FORMTopologySymmetries["func", #1, All] & ],
 Rule["vars", i_Integer] :> Rule[
   $FORMTopologySimplifyVariables[#, i] & ,
   Null],
 x_ :>
   (Message[MethodRules::norule, x];
    Rule[
      FORMComment["!!! MISSING RULE !!!"] & ,
      Null])};

Options[FORMTopology] =
{Method -> {"zero" -> 1, "symm" -> 1, "vars" -> 1}};

FORMTopology::usage = "\
FORMTopology[<top>, [<set>], [opts]] returns the complete FORM code \
for a basic topology, performing various notation changes (e.g. \
between factor or function form, scalar products or factor symbols) \
and simplifications (e.g. discarding vanishing or symmetrizing equal \
(sub-)topologies).";

FORMTopology::method = "\
Warning: Invalid option value(s) `1` for [Method] will be ignored.
Possible assignments are of the form _String -> _Integer.";

FORMTopology::dependent = "\
Warning: \"`1`\" still containts linearly dependent factors and is \
apparently not yet suitable for a Laporta reduction.
Perform mapping onto linearly independent sub-topologies first";

FORMTopology::incomplete = "\
Warning: \"`1`\" is still missing irreducible scalar products and is \
apparently not yet suitable for a Laporta reduction.
Perform completion of scalar products first.";

FORMTopology::error = "\
Warning: Error(s) occured during the call of a function specified via \
the [Method] option.";

(* plural *)
FORMTopology[
  tops_?TopologyListQ, set:Elective[SetupPattern[]],
  opts:OptionsPattern[]] :=
  (Status[Console, name /. #];
   FORMTopology[#, set, opts]) & /@ tops;

(* main *)
FORMTopology[
  top:TopologyPattern["Solve"], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {me, pk, wn, fc},
    (* check: Method *)
    me = OptionValue[Method];
    If[Head[me] =!= List,
       me = {me}];
    pk = MatchQ[#, _String -> _Integer] & /@ me;
    If[!And @@ pk,
       Message[FORMTopology::method, Pick[me, Not /@ pk]];
       me = Pick[me, pk]];
    me = # /. MethodRules[FORMTopology] & /@ me;
    wn = {};
    (* check: dependent *)
    If[TopologyDependentQ[top, set],
       Message[FORMTopology::dependent, name /. top];
       AppendTo[wn, FORMComment["!!! DEPENDENT FACTORS !!!"]]];
    (* check: incomplete *)
    If[!TopologyCompleteQ[top, set],
       Message[FORMTopology::incomplete, name /. top];
       AppendTo[wn, FORMComment["!!! INCOMPLETE FACTORS !!!"]]];
    (* generate, check calls *)
    fc = Check[
      If[# =!= Null,
         #[top, set, Sequence @@ FilterRules[{opts}, Options[#]]],
         Null],
      Message[FORMTopology::error];
      FORMComment["!!! CODE GENERATION ERROR !!!"]] & /@ (Last /@ me);
    (* result *)
    FORMFold[name /. top, FORMCode[
      "\n",
      FORMTopologyHeader[],
      "\n",
      If[wn =!= {},
         {wn, "\n"},
         {}],
      FORMTopologyComment[top, set],
      "\n",
      FORMNoIndent[FORMCode[
        "#include fsymm.prc\n",
        FORMIfNDef[
          "sym" <> (name /. top),
          FORMDefine["sym" <> (name /. top) -> 0]]]],
      "\n",
      FORMNoIndent[FORMTopologyDefine[top, set]],
      "\n",
      FORMTopologyFactors[top, set],
      "\n",
      FORMTopologyFunction[top, set],
      "\n",
      FORMTopologyExpand[top, set],
      "\n",
      FORMTopologyReduce[top, set],
      "\n",
      Riffle[DeleteCases[fc, Null], "\n"],
      "\n",
      FORMTopologySimplify[top, set, Sequence @@ FilterRules[
        {opts}, Options[FORMTopologySimplify]]],
      "\n"]]];

(* overload: "Setup" *)
FORMTopology[
  top:TopologyPattern["Setup"], opts:OptionsPattern[]] :=
  FORMTopology[top, setp /. top, opts];

(* trap *)
FORMTopology[___] :=
  (Message[FORMTopology::usage];
   Abort[]);

(* N.B.:
- Warns if topology <top> is dependent or incomplete.
- Includes procedures based on rules present in [Method].
- Passes the information from [Method] to FORMTopologySimplify.
*)

(* --- FORMTopologyApart -------------------------------------------- *)

Options[FORMTopologyApart] =
{BaseScaleFunction -> $FORMTopologyBaseScaleFunction};
(* _Function *)

FORMTopologyApart::usage = "\
FORMTopologyApart[<top>, [<set>]] returns FORM code performing partial \
fractioning decomposition for integrals in case <top> contains \
linearly dependent topology factors.";

FORMTopologyApart::unfactorized = "\
Warning: Partial fractioning relations for \"`1`\" contain \
unfactorized denominator(s) `2`.";

(* main *)
FORMTopologyApart[
  top:TopologyPattern[], set:SetupPattern[], opts:OptionsPattern[]] /;
MatchQ[rels /. top, {___, {__}}] :=
  Module[
    {c, bs,sr, rl, ck, cm, ct},
    (* helper: check if denominators are free of sums *)
    c = And @@ Function[x, FreeQ[Denominator[x], Plus]] /@
      If[Head[#] === Plus, List @@ #, List @ #] & ;
    (* base scale replacement *)
    bs = OptionValue[BaseScaleFunction];
    sr = bs[top, set] -> MM;
    (* relations *)
    rl = Last[rels /. top];
    (* check: unfactorized *)
    ck = c /@ Last /@ (rl /. FORMSymbol[_] -> FORMSymbol);
    If[!(And @@ ck),
       Message[FORMTopologyApart::unfactorized,
         name /. top, Pick[rl, Not /@ ck]]];
    (* rewrite relations *)
    rl = FORMIdentify[Factor[#]] &
      /@ ToDotProducts[rl /. sr, vs /. set];
    (* comment *)
    cm = FORMExpression[Factor[#]] &
      /@ ToDotProducts[Drop[rels /. top, -1], vs /. set];
    (* rewrite constraints, ignore mass assignments *)
    ct = FORMIdentify[Factor[#]] & /@ ToDotProducts[
      DeleteCases[cs /. set, m[_] -> _] /. sr, vs /. set];
    (* result: unfactorized *)
    If[!And @@ ck, Return[FORMCode[
      FORMComment["!!! RELATIONS NOT FACTORIZED !!!"],
      FORMComment /@ ToFORMCodeString /@ rl]]];
    (* result: factorized *)
    FORMProcedure["p" <> (name /. top), MM, FORMCode[
      FORMComment["partial fraction decomposition:"],
      FORMComment["  " <> ToFORMCodeString[#] & /@ cm],
      rl,
      If[ct =!= {},
         {FORMComment["kinematic constraints"],
          ct},
         {}]]]];

(* default: no "Solve" *)
FORMTopologyApart[
  top:TopologyPattern[], set:SetupPattern[], opts:OptionsPattern[]] :=
  FORMProcedure["p" <> (name /. top), MM, FORMCode[
    FORMComment["no partial fraction decomposition"]]];

(* overload: "Setup" *)
FORMTopologyApart[top:TopologyPattern["Setup"], opts:OptionsPattern[]] :=
  FORMTopologyApart[top, setp /. top];

(* trap *)
FORMTopologyApart[___] :=
  (Message[FORMTopologyApart::usage];
   Abort[]);

(* --- FORMTopologyMapping ------------------------------------------ TODO *)

FORMTopologyMapping::usage = "\
FORMTopologyMapping[<maps>, <top>] returns FORM code applying all \
symmetries of <top> necessary for mapping to the set of linearly \
independent sub-topologies specified via <maps>.";

FORMTopologyMapping::nomatch = "\
Warning: No matching mapping for \"`1`\" found.";

(* main *)
FORMTopologyMapping[
  maps:{MappingPattern[]...}, top:TopologyPattern["Subt"]] :=
  Module[
    {fs, ms,mr, st, h,g,f},
    fs = FORMForm /@ First /@ (facs /. top);
    (* matching mappings *)
    ms = Select[maps, (fr /. #) === (name /. top) & ];
    (* check: no match *)
    If[ms === {},
       Message[FORMTopologyMapping::nomatch, name /. top]];
    (* invert mappings *)
    mr = ReverseMapping /@ ms;
    (* sub-topology groups with more than one member *)
    st = Select[subt /. top, Length[#] > 1 & ];
    (* corresponding to mappings *)
    st = Function[m, Select[st, First[#] === (id /. m) & , 1]] /@ mr;
    st = First /@ DeleteCases[st, {}];
    (* helper: formatting; #1: contracted, #2: replacements *)
    h = Function[{zs, rs}, FORMIf[
      StringJoin[
        Riffle["(count(" <> # <> ",1) == 0)" & /@ zs, " &&\n    "]],
      StringJoin[
        "\n  mu replace_(", Riffle[Riffle[fs[[#]], ","] & /@ rs, ", "],
        ");\n"]]];
    (* helper: each representation; #1: reference, #2: representation *)
    g = Function[{ft, rt}, h[
      Complement[fs, fs[[rt]]],
      Select[Transpose[{rt, ft}], #[[1]] =!= #[[2]] & ]]];
    (* helper: subset mapping; #1: reference, #2: all representations *)
    f = Function[{ft, rt}, FORMCode[
      FORMComment[StringJoin[
        "mapping to (", Riffle[ToString /@ ft, ","], ")"]],
      g[ft, #] & /@ rt]];
    (* result *)
    FORMProcedure["m" <> (name /. top), FORMCode[
      FORMComment[If[st === {}, "no mappings", "prepare mappings"]],
      f[First[#], Rest[#]] & /@ st]]];

(* trap *)
FORMTopologyMapping[___] :=
  (Message[FORMTopologyMapping::usage];
   Abort[]);

(* --- FORMTopologyMappings ----------------------------------------- TODO *)

FORMTopologyMappings::usage = "\
FORMTopologyMappings[<top>, <maps>] returns FORM code performing the \
mapping of <top> onto each of the linearly independent sub-topologies \
specified in the set <maps>.";

FORMTopologyMappings::nomatch =
  FORMTopologyMapping::nomatch;

Options[FORMTopologyMappings] =
  Options[TopologyMomentaShifts];

(* case: mappings to zero *)
FORMTopologyMappings[
  maps_?MappingListQ, top:TopologyPattern[]] /;
Union[to /. maps /. to -> {}] === {0} :=
  Module[
    {sel, ms, fs,ft, f},
    (* matching mappings *)
    sel = Select[maps, (name /. top) === (fr /. #) & ];
    (* check: mappings found *)
    If[sel === {},
       Message[FORMTopologyMappings::nomap, name /. top];
       Return[FORMComment["!!! NO MAPPINGS FOUND !!!"]]];
    (* mapping permutations *)
    ms = id /. sel;
    (* factor symbols *)
    fs = ToString /@ First /@ (facs /. top);
    (* contracted line symbols *)
    ft = Pick[fs, #, 0] & /@ ms;
    (* formatting *)
    f = "(count(" <> # <> ",1) == 0)" & ;
    (* result *)
    FORMProcedure["m" <> (name /. top) <> "tZERO", FORMCode[
      FORMComment["mapping to ZERO"],
      FORMIf[StringJoin[Riffle[f /@ #, " &&\n    "]],
             "\n  discard;\n"] & /@ ft]]];





(* TODO: plural maps version *)

(* case: singular mappings, w/o momenta shifts *)
FORMTopologyMappings[
  map:MappingPattern[], top:TopologyPattern[], set:SetupPattern[]] /;
(to /. map) =!= 0 :=
  Module[
    {fs,ws, ls, im, ft,wt, fu, f},
    (* check: mapping matches *)
    If[(name /. top) =!= (fr /. map),
       Message[FORMTopologyMappings::nomatch, name /. top];
       Return[FORMComment["!!! NO MAPPINGS FOUND !!!"]]];
    (* factor, power symbols *)
    fs = ToString /@ First /@ (facs /. top);
    ws = "a" <> ToString[#] & /@ Range[Length[fs]];
    (* number of loops *)
    ls = ToString[nk /. (setp /. top)];
    (* inverted mapping *)
    im = id /. ReverseMapping[map];
    (* delete contracted lines <- should not occur for *complete* independents *)           (* TODO *)
    im = DeleteCases[im, 0];
    (* pick needed symbols *)
    {ft, wt} = Pick[#, id /. map, x_ /; x > 0] & /@ {fs, ws};               (* TODO: change Pick -> ??? *)
    (* contracted line symbols *)                                           (* TODO: var name *)
    fu = Complement[fs, ft];

    (* TODO: rename, ... *)
    f = FORMIf[StringJoin[Riffle["(count(" <> # <> ",1) == 0)" & /@ fu, " &&\n    "]], #] & ;

    (* result *)
    FORMProcedure[
      "m" <> (name /. top) <> "t" <> (to /. map),
      "marker", "MM", "M2ep", FORMCode[
        FORMComment[StringJoin["mapping to (", Riffle[ToString /@ im, ","], ")"]],
        If[fu =!= {}, f, Identity] @
          FORMCode["", FORMIdentify[                               (* TODO: FORMCode? -> No multicommand version! *)
            (StringJoin[
              "marker*",
              Riffle[MapThread[#1 <> "^" <> #2 <> "?" & ,
                               {ft, wt}], "*"],
              "\n "] ->
             StringJoin[
               "M2ep^(+", ls, ")*MM^(+2*", ls,
               " + " <> # & /@ ws[[im]],
               ")\n    *", to /. map, "(",
               Riffle["-" <> # & /@ ws[[im]], ","],
               ")"])
            ]]]]];






(* TODO: merge options *)

FORMTopologyMappings::match = "\
Warning: Names of objects \"`1`\" and \"`2`\" do not match.";

FORMTopologyMappings::nosubt = "\
Warning: No matching sub-topologies found in \"`1`\".";

FORMTopologyMappings::noshifts = "\
Warning: No momenta shifts determined from \"`1`\" to \"`2`\".";

(* case: singular mappings, w/ momenta shifts *)
$FORMTopologyMappings[
  map:MappingPattern[], src:TopologyPattern["Subt"], trg:TopologyPattern["Subt"],
    set:SetupPattern[], opts:OptionsPattern[]] /; (to /. map) =!= 0 :=
  Module[

    {os, pam, mp,pm, c1,c2, fail, sr,tr, sms,tms, srcs,trgs, tmp, fs,gs, rp,cm, mfunc, tmrp},

    os = FilterRules[{opts}, Options[TopologyMomentaShifts]];

    (*temp = OptionValue[Temporary];*)
    temp = "ptmp";

    tmrp = MapIndexed[
      #1 -> Symbol[temp <> ToString[#2[[1]]]] & ,
      vs /. set];

    (* check: names match *)
    If[(fr /. map) =!= (name /. src),
       Message[FORMTopologyMappings::match, fr /. map, name /. src]];
    If[(to /. map) =!= (name /. trg),
       Message[FORMTopologyMappings::match, to /. map, name /. trg]];

    pam = ReverseMapping[map, trg];

    mp = Sort[DeleteCases[id /. map, 0]];  (* gives subset of lines in trg *)
    pm = Sort[DeleteCases[id /. pam, 0]];  (* gives subset of lines in src*)

    c1 = Riffle[ToString /@ pm, ","];
    c2 = Riffle[ToString /@ mp, ","];
    fail = FORMCode[
      FORMComment["map from (" <> c1 <> ") to (" <> c2 <> ")"],
      FORMComment["!!! NO MAPPINGS FOUND !!!"]];

    sr = Select[subt /. src, MemberQ[Sort /@ #, pm] & ];
    tr = Select[subt /. trg, MemberQ[Sort /@ #, mp] & ];

    If[sr =!= {},
       sr = First[sr],
       Message[FORMTopologyMappings::nosubt, name /. src];
       Return[fail]];

    If[tr =!= {},
       tr = First[tr],
       Message[FORMTopologyMappings::nosubt, name /. trg];
       Return[fail]];

    (* need only one mapping for complete topology; other cases cannot occur by construction of >subt< *)
    sr = DeleteDuplicates[sr, Sort[#1] === Sort[#2] & ];

    fs = First /@ (facs /. src);
    gs = First /@ (facs /. trg);

    sms = ReverseMapping[MapIndexed[Mapping[(name /. src) <> "s" <> ToString[First[#2]], src, #1] & , sr], src];
    tms = ReverseMapping[MapIndexed[Mapping[(name /. trg) <> "s" <> ToString[First[#2]], trg, #1] & , tr], trg];

    srcs = MapToTopology[sms, src /. FORMSymbol[x_] -> x];
    trgs = MapToTopology[tms, trg /. FORMSymbol[x_] -> x];

    tmp = MapThread[Function[
      {s, sm}, Quiet[Catch[MapThread[Function[
        {tm, t}, Block[
          {ms = TopologyMomentaShifts[s, t, set, Sequence @@ os], rp},
          If[ms =!= $Failed,
             (*fs = First /@ (facs /. s);
             gs = First /@ (facs /. t);
             rp = MapIndexed[If[#1 === 0, 0, fs[[First[#2]]] -> gs[[#1]]] & , id /. sm];
             rp = DeleteCases[rp, 0];*)
             cm = (id /. ReverseMapping[sm]) -> (id /. ReverseMapping[tm]);
             rp = MapThread[fs[[#1]] -> gs[[#2]] & , List @@ cm];
             Throw[{cm, rp, ms}]];
          ms]], {tms, trgs}]]]], {srcs, sms}];

    If[!FreeQ[tmp, $Failed],
       Message[FORMTopologyMappings::noshifts, name /. src, name /.trg];
       Return[fail]];

    mfunc[comm_, repl_, shft_] := Module[
      {comm1, comm2, shft1, shft2, compl},
      comm1 = StringJoin[Riffle[ToString /@ comm[[1]], ","]];
      comm2 = StringJoin[Riffle[ToString /@ comm[[2]], ","]];
      (*shft2 = #[[1]] -> (#[[2]] /. tmrp) & /@ shft;*)
      shft1 = Select[shft, MemberQ[ps /. set, First[#]] & ];
      shft2 = Complement[shft, shft1];
      compl = ToString /@ Complement[fs, fs[[comm[[1]]]]];
      FORMCode[
        FORMComment["map from (" <> comm1 <> ") to (" <> comm2 <> ")"],
        If[compl =!= {}, FORMIf[StringJoin[Riffle["(count(" <> # <> ",1) == 0) && match(`marker')" & /@ compl, " &&\n    "]], #] & , # & ] @ FORMCode[
          FORMIdentify["marker" -> to /. map],                                        (*  HERE  *)
          FORMReplace[repl],
          FORMReplace[shft1],
          FORMReplace[shft2]
        ]]];

    FORMCode[mfunc @@@ tmp]];

(*
- In: src["subt"], trg, map
- find subt group in src corresp. to map
- try groups elems. until found mom. shifts
- apply symmetry w/ resp. to remaining groups elems.
=> also need to compute momentum shift!?
- load subt. .def file for rewriting notation
*)

(* case: plural mappings to same basic topology, w/ momenta shifts *)
$FORMTopologyMappings[
  maps_?MappingListQ, src:TopologyPattern["Subt"], trg:TopologyPattern["Subt"],
  set:SetupPattern[], opts:OptionsPattern[]] /; Length[DeleteCases[Union[to /. maps], 0]] === 1 :=
  Module[
    {map, tmp},
    map = First[maps];
    tmp = MapIndexed[FORMCode[
      FORMComment["subset " <> ToString[First[#2]]],
      $FORMTopologyMappings[#, src, trg, set, opts]] & , maps];
    FORMProcedure["m" <> (fr /. map) <> "t" <> (to /. map), "marker", "MM", "M2ep", FORMCode[
      tmp,
      ".sort\n",
      "#call c" <> (to /. map) <> "(MM)\n",
      ".sort\n",
      "#call g" <> (to /. map) <> "(MM,M2ep)\n",
      ".sort\n",
      "#call z" <> (to /. map) <> "\n",
      ".sort\n"]]];



(* main *)
FORMTopologyMappings[
  maps_?MappingListQ, src:TopologyPattern[],
  trgs:Elective[_?TopologyListQ], set:SetupPattern[]] :=
  Module[
    {ms, zs, ts},
    (* matching mappings *)
    ms = Select[maps, (fr /. #) === (name /. src) & ];
    (* check: no match *)
    If[ms === {},
       Message[FORMTopologyMappings::nomatch, name /. src];
       Return[FORMComment["!!! NO MAPPINGS FOUND !!!"]]];
    (* extract mappings to zero *)
    zs = Select[ms, (to /. #) === 0 & ];
    ms = Complement[ms, zs];

    ms = GatherBy[ms, to /. # & ];
    ts = Function[m, First[Select[trgs, (name /. #) === (to /. m) & ]]] /@ (First /@ ms);

    (*ts = Function[m, First[Select[trgs, (name /. #) === (to /. m) & , 1]]] /@ ms;*)

    (* TODO: check if trgs present, ts for found tops. *)

    (* result *)
    FORMCode[
      If[zs =!= {},
         FORMCode[FORMTopologyMappings[zs, src], "\n"], FORMCode[]],
      Riffle[MapThread[$FORMTopologyMappings[#1, src, #2, set] & , {ms, ts}], "\n"]]];

(* overload: no "Setup" *)
FORMTopologyMappings[
  maps_?MappingListQ, src:TopologyPattern["Setup"],
    trgs:Elective[_?TopologyListQ]] :=
  FORMTopologyMappings[maps, src, trgs, setp /. src];

(* trap *)
FORMTopologyMappings[___] :=
  (Message[FORMTopologyMappings::usage];
   Abort[]);

(* TODO:

- Really get naming and conditions in defs. right...

*)

(* --- FORMTopologyMain --------------------------------------------- TODO *)

$FORMTopologyMainMethods =
{"Complete", "Incomplete"};

(* TODO: check Method *)

Options[FORMTopologyMain] =
{BaseScaleFunction -> $FORMTopologyBaseScaleFunction,
 IncludeFunction -> $FORMTopologyIncludeFunction,
 LoadingFunction -> $FORMTopologyLoadingFunction[1],
 Method -> {}};

FORMTopologyMain::usage = "";

FORMTopologyMain::include = "\
Option value of [LoadingFunction] does not return a valid string!";            (* TODO *)

FORMTopologyMain::load = "\
Option value of [LoadingFunction] does not return a valid string!";            (* TODO *)

FORMTopologyMain::nomatch =
  FORMTopologyMapping::nomatch;

FORMTopologyMain[
  maps:{MappingPattern[]...}, top:TopologyPattern["Solve"],
    set:SetupPattern[], opts:OptionsPattern[]] :=
  Module[
    {nm, bf,if,lf,me, bs, sel,zer},
    (* topology name *)
    nm = name /. top;
    (* loading function *)
    {bf, if, lf, me} = OptionValue[
      {BaseScaleFunction, IncludeFunction, LoadingFunction, Method}];
    (* base scale *)
    bs = ToString[bf[top, set]];
    (* check: include function *)
    If[Head[if[""]] =!= String,
       Message[FORMTopologyMain::include]];
    (* check: loading function *)
    If[Head[lf[""]] =!= String,
       Message[FORMTopologyMain::load]];
    (* select matching mappings *)
    sel = Select[maps, nm === (fr /. #) & ];
    sel = (to /. #) & /@ sel;
    (* check: mappings found *)
    If[sel === {},
       Message[FORMTopologyMain::nomatch, nm]];
    (* extract mappings to zero *)
    zer = Cases[sel, 0];
    sel = DeleteCases[DeleteDuplicates[sel], 0];
    (* result *)
    FORMProcedure[nm, FORMCode[
      FORMMessage["this is \"" <> nm <> "\"..."],

      If[MemberQ[me, "Complete"],
         {FORMComment["reduce scalar products"],
          FORMMessage["reduce scalar products..."],
          "#call c" <> nm <> "(" <> bs <> ")\n",
          ".sort\n"}, {}],

      FORMComment["apply simplifications"],
      FORMMessage["apply simplifications..."],
      FORMRepeat[If[MatchQ[top, TopologyPattern["Zero"]],
                    "#call z" <> nm <> "\n", ""],
                 "#call p" <> nm <> "(" <> bs <> ")\n"],
      ".sort\n",
      (*If[MatchQ[top, TopologyPattern["Symm"]],
         {"#call y" <> nm <> "\n", ".sort\n"}, ""],*)
      FORMComment["map to independents"],
      If[zer === {} && sel === {},
         "<no mapping(s) found!>\n",                                      (* TODO *)
         {FORMMessage["map to independents..."],
          (*"#call m" <> nm <> "\n",*)
          "mu marker;\n",
          If[zer =!= {}, "#call m" <> (name /. top) <> "tZERO;\n.sort\n", ""],
          "#call m" <> nm <> "t" <> # <> "(marker," <> bs <>
            ",[(mu^2/" <> bs <> ")^ep])\n.sort\n" & /@ sel,
          FORMIf["count(marker,1) != 0", FORMCode[
            ("\n  exit \"Error: \\\"" <> nm <>
             "\\\" not completely mapped to independents.\";\n")]],
          FORMComment["symmetrize"],
          FORMIfDef["sym" <> #, FORMCode[
            FORMMessage["symmetrize \"" <> # <> "\"..."],
            "#call y" <> # <> "\n",
            ".sort\n"]] & /@ sel,
          FORMComment["load reduction tables"],
          FORMIfDef["use" <> #, FORMCode[
            FORMMessage["read table for \"" <> # <> "\"..."],
            lf[#],
            ".sort\n"]] & /@ sel}]]]];

(* overload: "Setup" *)
FORMTopologyMain[
  maps:{MappingPattern[]...}, top:TopologyPattern["Solve", "Setup"],
    opts:OptionsPattern[]] :=
  FORMTopologyMain[maps, top, setp /. top, opts];

(* trap *)
FORMTopologyMain[___] :=
  (Message[FORMTopologyMain::usage];
   Abort[]);

(* TODO:

- Swtich for symmetrization.

- Swtich for table loading.

*)

(* --- FORMTopologyProcess ------------------------------------------ TODO *)

(* -- helper  -- *)

FORMTopologyProcessMATAD["MATAD"] := FORMCode[
  FORMComment["perform mapping, change notation"],
  "#call initlines\n",
  FORMComment["trigger topology"],
  "#call " <> # <> "\n",
  "\n"] & ;

FORMTopologyProcessMATAD[] := FORMCode[] & ;



Options[FORMTopologyProcess] = Join[
  Options[FORMTopologyMain], Options[FORMToplogyMATAD]];

FORMTopologyProcess::usage = "";

(* plural *)
FORMTopologyProcess[
  f:Elective["MATAD"], maps_?MappingListQ, tops_?TopologyListQ,
    opts:OptionsPattern[]] :=
  (Status[Console, name /. #];
   FORMTopologyProcess[f, maps, #, opts]) & /@ tops;

(* plural *)
FORMTopologyProcess[
  f:Elective["MATAD"], maps_?MappingListQ, srcs_?TopologyListQ,
    trgs_?TopologyListQ, opts:OptionsPattern[]] :=
  (Status[Console, name /. #];
   FORMTopologyProcess[f, maps, #, trgs, opts]) & /@ srcs;

(*
FORMTopologyProcess[
  f:Elective["MATAD"], maps_?MappingListQ,
    top:TopologyPattern["Setup", "Solve", "Zero"],
    opts:OptionsPattern[]] :=
  FORMFold[name /. top, FORMCode[
    "\n",
    FORMTopologyHeader[],
    "\n",
    FORMNoIndent["#+\n"],
    FORMTopologyComment[top],
    FORMComment["(scheme w/ completion)"],
    FORMNoIndent["#-\n"],
    "\n",
    FORMTopologyReduce[top],
    "\n",
    FORMTopologyZeros["fact", top],
    "\n",
    FORMTopologyApart[top],
    "\n",
    FORMTopologyMapping[maps, top],
    "\n",
    FORMTopologyMappings[maps, top],
    "\n",
    FORMTopologyMain[
       maps, top, Method -> {"Complete"}, Sequence @@ FilterRules[
         {opts}, Options[FORMTopologyMain]]],
    "\n",
    FORMTopologyProcessMATAD[f][name /. top]]];
*)

FORMTopologyProcess[
  f:Elective["MATAD"], maps_?MappingListQ,
    src:TopologyPattern["Setup", "Solve", "Zero"], trgs_?TopologyListQ,
    opts:OptionsPattern[]] :=
  Module[
    {if, ms},
    if = OptionValue[IncludeFunction];                                        (* TODO: check *)
    ms = Select[maps, (fr /. #) === (name /. src) & ];
    FORMFold[name /. src, FORMCode[
      "\n",
      FORMTopologyHeader[],
      "\n",
      FORMNoIndent["#+\n"],
      FORMTopologyComment[src],
      FORMComment["(scheme w/o completion)"],
      FORMNoIndent["#-\n"],
      "\n",
      FORMNoIndent /@ if /@ DeleteDuplicates[to /. ms],
      "\n",
      FORMTopologyZeros["fact", src],
      "\n",
      FORMTopologyApart[src],
      "\n",
      FORMTopologyMappings[ms, src, trgs],
      "\n",


      FORMTopologyMain[
        ms, src, Method -> {"Incomplete"}, Sequence @@ FilterRules[
          {opts}, Options[FORMTopologyMain]]],


      "\n",
      FORMTopologyProcessMATAD[f][name /. src]]]];

(* TODO: adapt *)
(*
FORMTopologyProcess[
  maps_?MappingListQ,
  top:TopologyPattern["Setup", "Solve"],
  opts:OptionsPattern[]] :=
      FORMFold[name /. top, "\n",
           FORMTopologyHeader[], "\n",
             "#+\n",
             FORMTopologyComment[top],
             "#-\n\n",
             FORMTopologyReduce[top], "\n",
             FORMTopologyApart[top], "\n",
             FORMTopologyMapping[maps, top], "\n",
             FORMTopologyMappings[maps, top], "\n",
             FORMTopologyMain[maps, top, opts], "\n"];
*)

(* TODO: change to <set> defs. *)
(* DONE: version w/o mapping -> identical mapping *)

FORMTopologyProcess[
  f:Elective["MATAD"], map:MappingPattern[], top:TopologyPattern[],
  opts:OptionsPattern[]] :=
  FORMTopologyProcess[f, {map}, top, opts];

FORMTopologyProcess[
  f:Elective["MATAD"], top:TopologyPattern[], opts:OptionsPattern[]] :=
  FORMTopologyProcess[f, {Mapping[top]}, top, opts];

(* trap *)
FORMTopologyProcess[___] :=
  (Message[FORMTopologyProcess::usage];
   Abort[]);

(* N.B.: Order must be like this! *)

(* TODO: treat more cases? *)

(* --- -------------------------------------------------------------- *)







(* --- FORMTopologyMATAD -------------------------------------------- TODO *)

Options[FORMTopologyMATAD] =
{Externals -> "Q",
 Internals -> "p",
 Temporary -> "ptmp",
 Masses -> {Global`mt -> "1", Global`mh -> "2"}};

FORMTopologyMATAD::usage = "\
FORMTopologyMATAD[<top>, [<set>]] returns FORM code rewriting \
MATAD to TopoID notation.";

FORMTopologyMATAD::mass = "\
Warning: No mass assignment for `1` in option value of [Masses].";

(* main *)
FORMTopologyMATAD[
  top:TopologyPattern["Graph"], set:SetupPattern[],
    opts:OptionsPattern[]] :=
  Module[
    {es,is,ts,ms, fs,pr, fps, ims, ems,tms, emr,tmr, prs, lrs},

    {es, is, ts, ms} = OptionValue[
      {Externals, Internals, Temporary, Masses}];

    (* -- prepare factors, graph -- *)

    {fs, pr} = {facs, pros} /. top;

    (* only denominator symbols needed *)
    fs = First /@ fs;

    (* apply mass wrapper if needed *)
    pr = MapAt[If[Head[#] === String, m[#], #] & , #, {1}] & /@ pr;
    (* apply mass assignments *)
    pr = pr /. (cs /. set) /. ms;

    (* join needed data *)
    fps = MapThread[{#1, #2[[1]], #2[[2]]} & , {fs, pr}];

    (* clear pure numerators *)
    fps = DeleteCases[fps, {_, Null, _} | {_, _, 0}];

    (* -- momenta, replacements -- *)

    (* internal *)
    ims = MapIndexed[Symbol[is <> ToString[#2[[1]]]] & , fps];

    (* external, temporary *)
    ems = MapIndexed[Symbol[es <> ToString[#2[[1]]]] & , ps /. set];
    tms = MapIndexed[Symbol[ts <> ToString[#2[[1]]]] & , ps /. set];

    (* replacements *)
    emr = MapThread[Rule, {ems, tms}];
    tmr = MapThread[Rule, {ps /. set, tms}];

    (* -- propagator, line momenta replacements -- *)

    prs = MapThread[
      Switch[
        #2[[2]],
        (* massive line *)
        _String, "s" <> ToString[#3] <> "m" <> #2[[2]] -> 1/#2[[1]],
        (* massless line *)
        0, 1/(#1 . #1) -> 1/#2[[1]],
        (* error: undefined mass *)
        _, Message[FORMTopologyMATAD::mass, #2[[2]]]; {}] & ,
      {ims, fps, Range[Length[fps]]}];

    prs = prs /. {x_[i_Integer] /; MemberQ[{s, n, d}, x] :> Symbol[ToString[x] <> ToString[i]],
                  p[i_Integer] :> Symbol["d" <> ToString[i]]};

    lrs = MapThread[#1 -> (#2[[3]] /. tmr) & , {ims, fps}];

    (* -- result -- *)

    FORMCode[
      FORMComment["convert MATAD notation"],
      FORMProcedure["MATADto" <> (name /. top), FORMCode[
        FORMComment["propagators"],
        FORMIdentify /@ prs,
        ".sort\n",
        FORMComment["line momenta"],
        FORMIdentify /@ lrs,
        ".sort\n",
        FORMComment["external momenta"],
        FORMIdentify /@ emr,
        ".sort\n",
        FORMComment["temporary symbols"],
        FORMReplace[Reverse /@ tmr],
        ".sort\n"]]]];

(* TODO: check stuff *)

(* TODO: version w/o "Graph" *)

(* overload: "Setup" *)
FORMTopologyMATAD[
  top:TopologyPattern["Setup"]] :=
  FORMTopologyMATAD[maps, top, setp /. top];

(* trap *)
FORMTopologyMATAD[___] :=
  (Message[FORMTopologyMATAD::usage];
   Abort[]);

(* --- -------------------------------------------------------------- TODO *)

(* TODO: rename *)

Options[FORMTopologyMomentaShifts] =
{Temporary -> "ptmp"};

Options[FORMTopologyMomentaShifts] =
  Join @@ Options /@ {FORMTopologyMomentaShifts, TopologyMomentaShifts};

FORMTopologyMomentaShifts::noshifts = "\
Warning: No momenta shifts determined from \"`1`\" to \"`2`\".";

FORMTopologyMomentaShifts[
  map:MappingPattern[],
    src:TopologyPattern[], trg:TopologyPattern[],
    set:SetupPattern[], opts:OptionsPattern[]] :=
  Module[
    {tms, pam, stmp,ttmp, sft, fss,fst, drs},
    (* temporary symbols *)
    tms = MapIndexed[
      #1 -> Symbol[OptionValue[Temporary] <> ToString[#2[[1]]]] & ,
      vs /. set];
    (* reverse mapping, apply on target, compute shift *)
    pam = ReverseMapping[map, Length[facs /. trg]];
    stmp = MapToTopology[ComposeMapping[map, pam], src];
    ttmp = MapToTopology[pam, trg];
    sft = TopologyMomentaShifts[stmp, ttmp, set, Sequence @@ FilterRules[
      {opts}, Options[TopologyMomentaShifts]]];
    (* result *)
    sft = #[[1]] -> (#[[2]] /. tms) & /@ sft;
    fss = First /@ (facs /. src);
    fst = First /@ (facs /. trg);
    drs = MapIndexed[fss[[#2[[1]]]] -> fst[[#1]] &, id /. map];

    drs = drs /. {x_[i_Integer] /; MemberQ[{s, n, d}, x] :> Symbol[ToString[x] <> ToString[i]],
                  p[i_Integer] :> Symbol["d" <> ToString[i]]};

    If[sft === {},
       Message[
         FORMTopologyMomentaShifts::noshifts, name /. src, name /. trg];
       Return[FORMComment["!!! NO MOMENTA SHIFTS FOUND !!!"]]];

    FORMProcedure["m" <> (fr /. map) <> "t" <> (to /. map), FORMCode[
      FORMComment["rename denominators"],
      FORMReplace[drs],
      FORMComment["apply momenta shifts"],
      FORMIdentify /@ sft,
      FORMComment["replace temporary symbols"],
      FORMReplace[Reverse /@ tms]]]];

(* overload: "Setup" *)
FORMTopologyMomentaShifts[
  map:MappingPattern[],
    src:TopologyPattern["Setup"], trg:TopologyPattern[],
    opts:OptionsPattern[]] :=
  FORMTopologyMomentaShifts[map, dia, top, setp /. dia, opts];

(* overload: "Setup" *)
FORMTopologyMomentaShifts[
  map:MappingPattern[],
    src:TopologyPattern[], trg:TopologyPattern["Setup"],
    opts:OptionsPattern[]] :=
  FORMTopologyMomentaShifts[map, dia, top, setp /. top, opts];

(* trap *)
FORMTopologyMomentaShifts[___] :=
  (Message[FORMTopologyMomentaShifts::usage];
   Abort[]);

(* --- -------------------------------------------------------------- TODO *)

(* TODO: rename *)

Options[FORMDiaToTop] =
  Join[Options[FORMTopologyMATAD], Options[FORMTopologyMomentaShifts]];

FORMDiaToTop::usage = "TODO";

FORMDiaToTop[
  map:MappingPattern[],
    dia:TopologyPattern[], top:TopologyPattern[],
    set:SetupPattern[], opts:OptionsPattern[]] :=
  FORMFold[fr /. map, FORMCode[
    "\n",
    FORMComment["target topology"],
    FORMDefine["INTCOMBINED" -> (to /. map)],
    "\n",
    FORMComment["immediate notation change"],
    FORMReplace[MapIndexed[StringJoin[
      If[#2[[1]] > 1, "\n            ", ""],
      "p`JH1'", ToString[#2[[1]]]] ->
        "p`JH'" <> ToString[#2[[1]]] & ,
      id /. map]],
    "\n",
    FORMTopologyMATAD[dia, set, Sequence @@ FilterRules[
      {opts}, Options[FORMTopologyMATAD]]],
    "\n",
    FORMTopologyMomentaShifts[map, dia, top, set, Sequence @@ FilterRules[
      {opts}, Options[FORMTopologyMomentaShifts]]],
    "\n",
    FORMComment["to be called later"],
    FORMProcedure["initlines", FORMCode[
      "#call MATADto" <> (fr /. map) <> "\n",
      "#call m" <> (fr /. map) <> "t" <> (to /. map) <> "\n"]],
    "\n"]];

(* overload: "Setup" *)
FORMDiaToTop[
  map:MappingPattern[],
    dia:TopologyPattern["Setup"], top:TopologyPattern[],
    opts:OptionsPattern[]] :=
  FORMDiaToTop[map, dia, top, setp /. dia, opts];

(* overload: "Setup" *)
FORMDiaToTop[
  map:MappingPattern[],
    dia:TopologyPattern[], top:TopologyPattern["Setup"],
    opts:OptionsPattern[]] :=
  FORMDiaToTop[map, dia, top, setp /. top, opts];

(* trap *)
FORMDiaToTop[___] :=
  (Message[FORMDiaToTop::usage];
   Abort[]);

(* --- -------------------------------------------------------------- TODO *)

Options[FORMFacToTop] =
  Join[Options[FORMTopologyMATAD], Options[FORMTopologyMomentaShifts]];

FORMFacToTop::usage = "TODO";

FORMFacToTop::momenta = "\
Names for momenta exhausted.  Maybe check the routing of momenta in \
the input for linear combinations.  TODO";

FORMFacToTop[
  maps:{MappingPattern[]...}, dias:{TopologyPattern[]...},
    top:TopologyPattern[], set:SetupPattern[], opts:OptionsPattern[]] :=
  Module[
    {dnm, map, fcs,lgs,prs, fs,qs, fc,lg,pr, vrs,rls, dia, lhs,rhs,rps},

    dnm = StringJoin[Riffle[fr /. maps, "x"]];

    map = Mapping[dnm, name /. top, Join @@ (id /. maps)];  (* TODO: Need to check for duplicates?! *)

    (* -- *)

    fcs = lgs = prs = {};

    fs = MapIndexed[p[#2[[1]]] & , id /. map];
    qs = ks /. set;

    Do[

      If[qs === {},
         Message[FORMFacToTop::momenta];
         Abort[]];

      {fc, lg, pr} = {facs, legs, pros} /. dia;

      vrs = Complement[Variables[#[[2]] & /@ pr], ps /. set];
      rls = MapThread[Rule, {vrs, Take[qs, Length[vrs]]}];
      qs = Drop[qs, Length[vrs]];

      fc = MapThread[Rule, {Take[fs, Length[fc]], (Last /@ fc) /. rls}];
      fs = Drop[fs, Length[fc]];

      fcs = Join[fcs, fc];
      prs = Join[prs, pr /. rls];

      , {dia, dias}];

    lgs = legs /. dias[[1]];

    dia = Topology[name -> dnm, facs -> fcs, legs -> lgs, pros -> prs];

    (* -- *)

    lhs = Join @@ MapIndexed[Function[{m, i}, MapIndexed[StringJoin[
      If[i[[1]] > 1 && #2[[1]] === 1,  "\n            ", ""], "p`JH",
      ToString[i[[1]]], "'", ToString[#2[[1]]]] & , m]], id /. maps];
    rhs = MapIndexed["p`JH'" <> ToString[#2[[1]]] & , id /. map];
    rps = Rule @@@ Transpose[{lhs, rhs}];

    FORMFold[fr /. map, FORMCode[
      "\n",
      FORMDefine["FACTOR" -> Length[maps]],
      "\n",
      FORMComment["target topology"],
      FORMDefine["INTCOMBINED" -> (to /. map)],
      "\n",
      FORMComment["immediate notation change"],
      FORMReplace[rps],
      "\n",
      FORMTopologyMATAD[dia, set, Sequence @@ FilterRules[
        {opts}, Options[FORMTopologyMATAD]]],
      "\n",
      FORMTopologyMomentaShifts[map, dia, top, set, Sequence @@ FilterRules[
        {opts}, Options[FORMTopologyMomentaShifts]]],
      "\n",
      FORMComment["to be called later"],
      FORMProcedure["initlines", FORMCode[
        "#call MATADto" <> (fr /. map) <> "\n",
        "#call m" <> (fr /. map) <> "t" <> (to /. map) <> "\n"]],
      "\n"]]];

(* overload: "Setup" *)
FORMFacToTop[
  maps:{MappingPattern[]...}, dias:{TopologyPattern[]...},
    top:TopologyPattern["Setup"], opts:OptionsPattern[]] :=
  FORMFacToTop[maps, dias, top, setp /. top, opts];

(* trap *)
FORMFacToTop[___] :=
  (Message[FORMFacToTop::usage];
   Abort[]);

(* --- -------------------------------------------------------------- TODO *)

ClearAll[FORMFacToZero];

FORMFacToZero[
  dias:{TopologyPattern[]...}] :=
  Module[
    {dnm},
    dnm = StringJoin[Riffle[name /. dias, "x"]];
    FORMFold[dnm, FORMCode[
      "\n",
      FORMDefine["FACTOR" -> 0],
      "\n",
      FORMComment["topology mapped to ZERO"],
      "\n"]]];

(* --- package end -------------------------------------------------- *)

Protect["TopoID`Code`*"];

Scan[
  SetAttributes[#, {ReadProtected}] & ,
  Select[Symbol /@ Names["TopoID`Code`*"], Head[#] === Symbol & ]];

End[];

EndPackage[];

(* ------------------------------------------------------------------ *)

(* --- TODO:

- Check application of BaseScaleFunction in
    FORMTopologyDefine[],
    FORMTopologyExpand[],
    FORMTopologyReduce[],
    FORMTopologyApart[]?

- pass options to FORM... (almost) everywhere?

- TODOs

- Unprotect certain symbols?

- Options[...] = Join[...]

*)
